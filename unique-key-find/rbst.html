<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      Unique Key Generation By Gap Insertion In Skip Lists And Binary Trees
    </title>
    <link rel="stylesheet" href="styles/mono-blue.css">
    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <link rel="stylesheet" href="style.css">
    <script type="text/javascript">
    function go_back(a){
      if(history.length > 1){
        history.back();
      } else {
        window.location = "index.html"
      }
    }
    </script>
  </head>
  <body>
    <div class="container">
      <div class="content-double">
<pre><code>
/* file: rbst.h */

#ifndef RBST_H
#define RBST_H

#include "common.h"

struct RBST {
  struct RBSTNode* root;
  int min;
  int max;
  int MAX_DEPTH;
  bool write_lock;
};

struct RBSTNode {
  int key;
  void* value;
  struct RBSTNode* links[2];
  int count;
};

struct RBST* rbst_create(int min, int max);

void rbst_free(struct RBST* rbst);

int rbst_gap_insert(struct RBST* tree, void* value);

void* rbst_find(const struct RBST* const tree, int key);

void* rbst_remove(struct RBST* tree, int key);

void rbst_for_each(struct RBST* rbst, void (*f)(int, void*));

void rbst_preord_apply(struct RBST* rbst, void (*f)(struct RBSTNode*));

void rbst_postord_apply(struct RBST* rbst, void (*f)(struct RBSTNode*));

void rbst_inord_apply(struct RBST* rbst, void (*f)(struct RBSTNode*));

int rbst_count(const struct RBST* const tree);

int rbst_gap_count(const struct RBST* const tree);

#endif

</code></pre>

<pre><code>
/* file: rbst.c */

#include "common.h"
#include "rbst.h"

#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt; // NULL
#include &lt;math.h&gt;   // log, rand, ceil, ...

// allowable deviation from log N depth (used to allocate stack) 
#define MAX_DEPTH_FACTOR 1.2

/* helper functions */

int rnd_bool()
{
  unsigned int base_random = rand(); /* in [0, RAND_MAX] */
  return (base_random & (1)) &gt; 0;    /* is odd? */
}

int middle(int a, int b)
{
  int difference = b - a;
  assert(abs(difference) &gt; 1); 
  return (a + (b - a) / 2);
}

int key_distance (int a, int b)
{
  return abs(b - a);
}

int keys_between(int a, int b)
{
  if(a == b) return 0;
  return key_distance(a, b) - 1;
}

int count(const struct RBSTNode* const node)
{
  if(!node) return 0;
  return node-&gt;count;
}

#define IN_ORDER   0x01
#define POST_ORDER 0x02
#define PRE_ORDER  0x03

void apply_for_each(struct RBST* rbst, void (*f)(struct RBSTNode*), int order)
{
  rbst-&gt;write_lock = true;

  if(!rbst-&gt;root)
    return;

  struct RBSTNode* stack[rbst-&gt;MAX_DEPTH];
  int sp = 0;
  stack[0] = rbst-&gt;root;
  int from = -1;
  do {
    // prefer left links if they are not visited
    int dir = from == 0 || stack[sp]-&gt;links[0] == NULL;
    
    // if going to right and not back from right
    if(order == IN_ORDER && dir && from &lt; 1)
      f(stack[sp]); // in ord
    
    // if haven't visited any sub nodes yet
    if(order == PRE_ORDER && from &lt; 0) 
      f(stack[sp]); // pre order
    
    struct RBSTNode* next = stack[sp]-&gt;links[dir];

    // if back from right or no right
    if(!next || from == 1) { 
      // record relation to parent we are returning to
      from = sp &gt; 0 ? stack[sp]-&gt;key &gt; stack[sp-1]-&gt;key : -1;
      
      if(order == POST_ORDER)
        f(stack[sp]); // post order
      
      // return to parent
      sp = sp - 1;
    } else {
      // not returning from anywhere, going down
      from = -1;
      stack[++sp] = next;
    }
  } while(sp &gt; -1); // until stack is empty

  rbst-&gt;write_lock = false;
}

struct RBSTNode* create_node(int key, void* value)
{
  struct RBSTNode* node = NEW(struct RBSTNode);
  node-&gt;links[0] = NULL;
  node-&gt;links[1] = NULL;
  node-&gt;value = value;
  node-&gt;count = 1;
  node-&gt;key = key;
  return node;
}

void remove_node(struct RBSTNode* node)
{
  free(node);
}

struct RBST* rbst_create(int min, int max)
{
  struct RBST* tree = NEW(struct RBST);
  tree-&gt;min = min;
  tree-&gt;max = max;
  tree-&gt;root = NULL;
  
  // maximum expected tree depth (used to allocate stack)
  tree-&gt;MAX_DEPTH = ceil(MAX_DEPTH_FACTOR*(log(max-min)/log(2)));
  
  // used to lock tree changes during iteration
  tree-&gt;write_lock = false;
  return tree;
}

void rbst_free(struct RBST* rbst)
{
  rbst_postord_apply(rbst, remove_node);
  free(rbst);
}

/* Find a gap and insert value there returning it's key, O(log N) time
 * Return 0 if no gap was available, constant time */
int rbst_gap_insert(struct RBST* tree, void* value)
{
  assert(tree);
  assert(!tree-&gt;write_lock);

  // initial boundaries
  int min = tree-&gt;min;
  int max = tree-&gt;max;

  // check if tree has any gaps at all
  if((keys_between(min, max) - count(tree-&gt;root)) == 0)
  {
    return 0;
  }
  
  // handle special case when root is NULL
  if(tree-&gt;root == NULL)
  {
    int key = middle(min, max);
    tree-&gt;root = create_node(key, value);
    return key;
  }

  // find any node adjacent to a gap
  // store node at "it" and gap boundaries in "min", "max"
  int dir;
  struct RBSTNode* it = tree-&gt;root;
  for(;;) {
    int bias = rnd_bool();
    int gaps_left = keys_between(min, it-&gt;key) - count(it-&gt;links[0]);
    int gaps_right = keys_between(it-&gt;key, max) - count(it-&gt;links[1]);

    // select any branch having gaps, select randomly if both available
    dir = (!bias && !(gaps_left &gt; 0)) || (bias && (gaps_right &gt; 0));

    // apply boundary propagation rules
    if(!dir) 
      max = it-&gt;key; 
    else
      min = it-&gt;key;

    // increment actual size, since we know gap is available somewhere
    // and insertion is guaranteed to succeed along this path
    it-&gt;count++;

    // check if current node has open link on the side of gap
    if(it-&gt;links[dir] == NULL)
      break;

    // continue along branch where gaps are
    it = it-&gt;links[dir];
  }

  // select any key from the gap and create node there
  int key = middle(min, max);
  it-&gt;links[dir] = create_node(key, value);

  return key;
}

void* rbst_find(const struct RBST* const tree, int key)
{
  struct RBSTNode* it = tree-&gt;root;
  while(it != NULL) {
    if(it-&gt;key == key)
      return it-&gt;value;
    else
    {
      int dir = key &gt; it-&gt;key;
      it = it-&gt;links[dir];
    }
  }
  return NULL;
}

void* rbst_remove(struct RBST* tree, int key)
{
  assert(tree);
  assert(!tree-&gt;write_lock);

  int depth_count = 0;

  // for deletion, stack is required to postpone count updates
  // since we don't know in advance if key is in the tree
  struct RBSTNode* stack[tree-&gt;MAX_DEPTH];
  int sp = 0;

  struct RBSTNode* target;
  
  // nothing to delete
  if(!tree-&gt;root)
   return NULL;
    
  stack[0] = tree-&gt;root;

  // find node to be deleted, store it at the top of the stack
  while(stack[sp] != NULL) {
    assert(++depth_count &lt;= tree-&gt;MAX_DEPTH);
    if(stack[sp]-&gt;key == key)
      break;
    struct RBSTNode* next = stack[sp]-&gt;links[key &gt; stack[sp]-&gt;key];
    stack[++sp] = next;
  }

  // nothing to remove, key not found
  if(stack[sp] == NULL)
    return NULL;
  
  // save target for later
  target = stack[sp];

  // node is considered hard case if it has two children
  int hard_case = stack[sp]-&gt;links[0] && stack[sp]-&gt;links[1];

  // find successor/predecessor for hard-case nodes and place it on top of the stack
  if(hard_case)
  {
    struct RBSTNode* replaced = stack[sp];
    int dir = rnd_bool();
    stack[++sp] = replaced-&gt;links[dir];
    while(stack[sp]-&gt;links[!dir] != NULL) {
      assert(++depth_count &lt;= tree-&gt;MAX_DEPTH);
      struct RBSTNode* next = stack[sp]-&gt;links[!dir];
      stack[++sp] = next;
    }
  }
  
  // inherit a link from deleted node, if at has any
  struct RBSTNode* inheritance = stack[sp]-&gt;links[stack[sp]-&gt;links[1] != NULL];
  
  // if there's parent update it's link
  if(sp &gt; 0) 
    stack[sp - 1]-&gt;links[stack[sp]-&gt;key &gt; stack[sp - 1]-&gt;key] = inheritance;
  else // otherwise update root
    tree-&gt;root = inheritance; 
  
  // save value to return later
  void* value = target-&gt;value;

  // replace target's key for hard cases with successor or predecessor
  if(hard_case)
  {
    target-&gt;key = stack[sp]-&gt;key;
    target-&gt;value = stack[sp]-&gt;value;
  }

  // delete whatever is at the top
  free(stack[sp]);
  
  // if traversed path is past the root (sp &gt; 0) 
  // update counts along traversed path down to stack[0],
  // but not including stack[sp], the deleted node
  while(sp--) {
    stack[sp]-&gt;count--;
  }

  return value;
}

void rbst_for_each(struct RBST* rbst, void (*f)(int, void*))
{
  rbst-&gt;write_lock = true;

  void pair_apply(struct RBSTNode* node)
  {
    f(node-&gt;key, node-&gt;value);
  }

  rbst_inord_apply(rbst, pair_apply);

  rbst-&gt;write_lock = false;
}

void rbst_preord_apply(struct RBST* rbst, void (*f)(struct RBSTNode*))
{
  apply_for_each(rbst, f, PRE_ORDER);
}

void rbst_postord_apply(struct RBST* rbst, void (*f)(struct RBSTNode*))
{
  apply_for_each(rbst, f, POST_ORDER);
}

void rbst_inord_apply(struct RBST* rbst, void (*f)(struct RBSTNode*))
{
  apply_for_each(rbst, f, IN_ORDER);
}

int rbst_count(const struct RBST* const tree)
{
  return count(tree-&gt;root);
}

int rbst_gap_count(const struct RBST* const tree)
{
  return keys_between(tree-&gt;min, tree-&gt;max) - rbst_count(tree);
}

</code></pre>

<a href='javascript:go_back("index.html")'>Back</a>
      </div>
    </div>
  </body>
</html>